# ë”¸ê¸° í™˜ê²½ ì œì–´ ì‹œë®¬ë ˆì´í„° - ì œì–´ ë¡œì§ ì½”ë“œ êµ¬í˜„ ê°€ì´ë“œ

**ë²„ì „:** v2.1  
**ì‘ì„±ì¼:** 2025-08-29  
**í˜•ì‹:** ì½”ë“œ êµ¬í˜„ ë¶€ë¶„ë³„ ìƒì„¸ ê°€ì´ë“œ  

---

## ğŸ“‹ ëª©ì°¨
1. [FOG ë¶„ë¬´ ì œì–´](#1-fog-ë¶„ë¬´-ì œì–´)
2. [FCU íŒ¬ì½”ì¼ ì œì–´](#2-fcu-íŒ¬ì½”ì¼-ì œì–´)
3. [COâ‚‚ ê³µê¸‰ ì œì–´](#3-coâ‚‚-ê³µê¸‰-ì œì–´)
4. [ë³´ì˜¨ì»¤íŠ¼ ì œì–´](#4-ë³´ì˜¨ì»¤íŠ¼-ì œì–´)
5. [ì°¨ê´‘ìŠ¤í¬ë¦° ì œì–´](#5-ì°¨ê´‘ìŠ¤í¬ë¦°-ì œì–´)
6. [ê´€ìˆ˜ì‹œìŠ¤í…œ ì œì–´](#6-ê´€ìˆ˜ì‹œìŠ¤í…œ-ì œì–´)
7. [ìœ ë™íŒ¬ ì œì–´](#7-ìœ ë™íŒ¬-ì œì–´)
8. [ì²œì°½ ì œì–´](#8-ì²œì°½-ì œì–´)
9. [í†µí•© ì œì–´ ì‹œìŠ¤í…œ](#9-í†µí•©-ì œì–´-ì‹œìŠ¤í…œ)

---

## 1. FOG ë¶„ë¬´ ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class FOGController:
    def __init__(self):
        self.start_time = None      # ë™ì‘ ì‹œì‘ ì‹œê°„
        self.stop_time = None       # ëŒ€ê¸° ì‹œì‘ ì‹œê°„  
        self.last_status = None     # ì´ì „ ìƒíƒœ (ë¡œê·¸ ì¤‘ë³µ ë°©ì§€)
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: íƒ€ì´ë¨¸ ìƒíƒœì™€ ë¡œê·¸ ê´€ë¦¬ë¥¼ ìœ„í•œ ë³€ìˆ˜ ì´ˆê¸°í™”

### ğŸ”§ **ì„¤ì •ê°’ ë¡œë“œ ë¶€ë¶„**
```python
def update(self, sensors, section, current_time):
    fog_config = RULES.get('FOG_CONTROL', {}).get(str(section), {})
    threshold = fog_config.get('threshold', 0)        # ì˜¨ë„ ì„ê³„ê°’
    run_time = fog_config.get('run_time', 0)          # ë™ì‘ì‹œê°„ (ms)
    delay_time = fog_config.get('delay_time', 0)      # ëŒ€ê¸°ì‹œê°„ (ms)
    
    logic_name = f"FOG_êµ¬ê°„{section}_ì˜¨ë„ê¸°ì¤€"
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: JSONì—ì„œ êµ¬ê°„ë³„ ì„¤ì •ê°’ì„ ì½ì–´ì™€ ë³€ìˆ˜ì— ì €ì¥

### ğŸ”§ **ì¤‘ì§€ ì¡°ê±´ ê²€ì‚¬ ë¶€ë¶„**
```python
if sensors['rain'] or run_time == 0 or sensors['temperature'] < threshold:
    if self.start_time or self.stop_time:
        if sensors['rain']:
            log_message = f"{logic_name}: ê°•ìš°ê°ì§€ë¡œ ì¤‘ì§€"
        elif run_time == 0:
            log_message = f"{logic_name}: êµ¬ê°„{section} ë¹„í™œì„± ì‹œê°„ëŒ€ë¡œ ì¤‘ì§€"
        else:
            log_message = f"{logic_name}: ì˜¨ë„ {sensors['temperature']}â„ƒ < {threshold}â„ƒë¡œ ì¤‘ì§€"
            
    self.start_time = self.stop_time = None
    return {'status': 'ì¤‘ì§€', 'code': 0}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ê°•ìš°, ë¹„í™œì„± êµ¬ê°„, ì €ì˜¨ ì¡°ê±´ ê²€ì‚¬í•˜ì—¬ ê°•ì œ ì¤‘ì§€

### ğŸ”§ **ë™ì‘ ì‹œì‘ ë¶€ë¶„**
```python
if not self.start_time and not self.stop_time:
    self.start_time = current_time
    log_message = f"{logic_name}: ì˜¨ë„ {sensors['temperature']}â„ƒ â‰¥ {threshold}â„ƒë¡œ ë¶„ë¬´ ì‹œì‘"
    return {'status': 'ë™ì‘', 'code': 1}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì•„ë¬´ íƒ€ì´ë¨¸ë„ ì—†ì„ ë•Œ ì¡°ê±´ ë§Œì¡±í•˜ë©´ ë™ì‘ ì‹œì‘

### ğŸ”§ **ë™ì‘ ì¤‘ ì‹œê°„ ì²´í¬ ë¶€ë¶„**
```python
elif self.start_time:
    elapsed = (current_time - self.start_time).total_seconds() * 1000
    if elapsed < run_time:
        return {'status': 'ë™ì‘', 'code': 1}, None  # ë¡œê·¸ ì—†ìŒ
    else:
        self.stop_time = current_time
        self.start_time = None
        log_message = f"{logic_name}: {int(run_time/1000)}ì´ˆ ë™ì‘ ì™„ë£Œ, {int(delay_time/60000)}ë¶„ ëŒ€ê¸°"
        return {'status': 'ì¤‘ì§€', 'code': 0}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì„¤ì •ëœ ë™ì‘ì‹œê°„ ê²½ê³¼í•˜ë©´ ëŒ€ê¸°ëª¨ë“œë¡œ ì „í™˜

### ğŸ”§ **ëŒ€ê¸° ì¤‘ ì¬ì‹œì‘ ì¡°ê±´ ë¶€ë¶„**
```python
elif self.stop_time:
    elapsed = (current_time - self.stop_time).total_seconds() * 1000
    if elapsed < delay_time:
        return {'status': 'ì¤‘ì§€', 'code': 0}, None
    else:
        self.stop_time = None
        if sensors['temperature'] >= threshold:
            self.start_time = current_time
            log_message = f"{logic_name}: ëŒ€ê¸°ì™„ë£Œ, ì˜¨ë„ {sensors['temperature']}â„ƒë¡œ ì¬ì‹œì‘"
            return {'status': 'ë™ì‘', 'code': 1}, log_message
        else:
            return {'status': 'ì¤‘ì§€', 'code': 0}, None
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ëŒ€ê¸°ì‹œê°„ ê²½ê³¼ í›„ ì˜¨ë„ ì¡°ê±´ ì¬ê²€ì‚¬í•˜ì—¬ ì¬ì‹œì‘ ê²°ì •

---

## 2. FCU íŒ¬ì½”ì¼ ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class FCUController:
    def __init__(self):
        self.state = {}  # êµ¬ê°„ë³„ ìƒíƒœ ì €ì¥ ë”•ì…”ë„ˆë¦¬
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ë³„ ë…ë¦½ì ì¸ ON/OFF ìƒíƒœ ê´€ë¦¬

### ğŸ”§ **êµ¬ê°„ ìœ íš¨ì„± ê²€ì‚¬ ë¶€ë¶„**
```python
def update(self, sensors, section, current_time):
    fcu_config = RULES.get('FCU_CONTROL', {}).get(str(section))
    if not fcu_config:
        return {'status': 'ëŒ€ê¸°', 'code': 2}, None  # ë¹„í™œì„± êµ¬ê°„
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: í•´ë‹¹ êµ¬ê°„ì´ FCU ì œì–´ ëŒ€ìƒì¸ì§€ í™•ì¸

### ğŸ”§ **íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì„ê³„ê°’ ì„¤ì • ë¶€ë¶„**
```python
on_threshold = fcu_config['on_threshold']   # ê°€ë™ ì˜¨ë„ (ë†’ìŒ)
off_threshold = fcu_config['off_threshold'] # ì¤‘ì§€ ì˜¨ë„ (ë‚®ìŒ)

if section not in self.state:
    self.state[section] = 'off'  # ì´ˆê¸°ê°’: ì¤‘ì§€
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ë³„ ìƒí•œ/í•˜í•œ ì˜¨ë„ì™€ ì´ˆê¸°ìƒíƒœ ì„¤ì •

### ğŸ”§ **ì˜¨ë„ ìƒìŠ¹ ì‹œ ê°€ë™ ë¶€ë¶„**
```python
if self.state[section] == 'off' and sensors['temperature'] >= on_threshold:
    self.state[section] = 'on'
    log_message = f"{logic_name}: ì˜¨ë„ {sensors['temperature']}â„ƒ â‰¥ {on_threshold}â„ƒë¡œ ëƒ‰ë°© ì‹œì‘"
    return {'status': 'ë™ì‘', 'code': 1}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: OFF ìƒíƒœì—ì„œ ì˜¨ë„ê°€ ìƒí•œê°’ ì´ìƒ ì‹œ ONìœ¼ë¡œ ì „í™˜

### ğŸ”§ **ì˜¨ë„ í•˜ê°• ì‹œ ì¤‘ì§€ ë¶€ë¶„**
```python
elif self.state[section] == 'on' and sensors['temperature'] <= off_threshold:
    self.state[section] = 'off'
    log_message = f"{logic_name}: ì˜¨ë„ {sensors['temperature']}â„ƒ â‰¤ {off_threshold}â„ƒë¡œ ëƒ‰ë°© ì¤‘ì§€"
    return {'status': 'ì¤‘ì§€', 'code': 0}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ON ìƒíƒœì—ì„œ ì˜¨ë„ê°€ í•˜í•œê°’ ì´í•˜ ì‹œ OFFë¡œ ì „í™˜

### ğŸ”§ **ìƒíƒœ ìœ ì§€ ë¶€ë¶„**
```python
else:
    status_text = 'ë™ì‘' if self.state[section] == 'on' else 'ì¤‘ì§€'
    code = 1 if self.state[section] == 'on' else 0
    return {'status': status_text, 'code': code}, None  # ë¡œê·¸ ì—†ìŒ
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì˜¨ë„ê°€ ìƒí•œ/í•˜í•œ ì‚¬ì´ì— ìˆì„ ë•Œ í˜„ì¬ ìƒíƒœ ìœ ì§€

---

## 3. COâ‚‚ ê³µê¸‰ ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class CO2Controller:
    def __init__(self):
        self.last_status = None  # ì´ì „ ìƒíƒœ (ë¡œê·¸ ì¤‘ë³µ ë°©ì§€)
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ìƒíƒœ ë³€ê²½ ê°ì§€ë¥¼ ìœ„í•œ ë³€ìˆ˜

### ğŸ”§ **ê¸°ë³¸ ì„¤ì •ê°’ ë¡œë“œ ë¶€ë¶„**
```python
co2_config = RULES.get('CO2_CONTROL', {}).get(str(section), {})
trigger = co2_config.get('trigger', 200)    # ê³µê¸‰ ì‹œì‘ ë†ë„
target = co2_config.get('target', 300)      # ëª©í‘œ ë†ë„
original_target = target  # ì›ë³¸ ëª©í‘œê°’ ë³´ê´€
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ë³„ ê¸°ë³¸ trigger/target ë†ë„ ì„¤ì •

### ğŸ”§ **í™˜ê²½ ë³´ì • ì¡°ê±´ ê²€ì‚¬ ë¶€ë¶„**
```python
modifiers = RULES.get('CO2_MODIFIERS', {})
modifiers_text = []

if sensors['light'] <= modifiers.get('light_threshold', 50):
    target *= modifiers.get('light_multiplier', 0.8)
    modifiers_text.append(f"ì¼ì‚¬ëŸ‰{sensors['light']}â‰¤50(Ã—0.8)")

if sensors['rain']:
    target *= modifiers.get('rain_multiplier', 0.6)
    modifiers_text.append("ê°•ìš°(Ã—0.6)")

if sensors['humidity'] >= modifiers.get('humidity_threshold', 85):
    target *= modifiers.get('humidity_multiplier', 0.7)
    modifiers_text.append(f"ìŠµë„{sensors['humidity']}%â‰¥85%(Ã—0.7)")
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì¼ì‚¬ëŸ‰, ê°•ìš°, ìŠµë„ ì¡°ê±´ì— ë”°ë¼ ëª©í‘œê°’ ë™ì  ë³´ì •

### ğŸ”§ **ê³µê¸‰ ì‹œì‘ ì¡°ê±´ ë¶€ë¶„**
```python
if sensors['co2'] <= trigger or sensors['co2'] < target:
    current_status = f'{round(target)}ppm ê³µê¸‰ì¤‘'
    if self.last_status != current_status:
        if modifiers_text:
            log_message = f"{logic_name}: COâ‚‚ {sensors['co2']}ppm < {round(target)}ppm, ë³´ì •ì¡°ê±´({', '.join(modifiers_text)})"
        else:
            log_message = f"{logic_name}: COâ‚‚ {sensors['co2']}ppm < {round(target)}ppmìœ¼ë¡œ ê³µê¸‰ ì‹œì‘"
    return {'status': current_status, 'code': 1}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: trigger ì´í•˜ê±°ë‚˜ ë³´ì •ëœ target ì´í•˜ ì‹œ ê³µê¸‰ ì‹œì‘

### ğŸ”§ **ê³µê¸‰ ì™„ë£Œ ì¡°ê±´ ë¶€ë¶„**
```python
else:
    current_status = 'ëŒ€ê¸°'
    if self.last_status and 'ê³µê¸‰ì¤‘' in self.last_status:
        log_message = f"{logic_name}: COâ‚‚ {sensors['co2']}ppm â‰¥ {round(target)}ppmìœ¼ë¡œ ê³µê¸‰ ì™„ë£Œ"
    return {'status': current_status, 'code': 2}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ëª©í‘œ ë†ë„ ë‹¬ì„± ì‹œ ê³µê¸‰ ì¤‘ì§€

---

## 4. ë³´ì˜¨ì»¤íŠ¼ ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class CurtainController:
    def __init__(self):
        self.start_time = None    # ë™ì‘ ì‹œì‘ ì‹œê°„
        self.last_status = None   # ì´ì „ ìƒíƒœ
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì‹œê°„ ê¸°ë°˜ ë™ì‘ì„ ìœ„í•œ íƒ€ì´ë¨¸ì™€ ìƒíƒœ ê´€ë¦¬

### ğŸ”§ **êµ¬ê°„ 1 ì™¸ê¸°ì˜¨ ë³´ì • ë¶€ë¶„**
```python
if section == 1:
    config = curtain_config.get('1', {})
    threshold = config.get('base_threshold', 15)  # ê¸°ë³¸ 15â„ƒ
    
    # ì™¸ê¸°ì˜¨ì— ë”°ë¥¸ ì„ê³„ê°’ ë™ì  ì¡°ì •
    if sensors['out_temp'] >= 0:
        threshold = config['out_temp_adjustments']['above_0']      # 12â„ƒ
    elif sensors['out_temp'] >= -10:
        threshold = config['out_temp_adjustments']['minus_10_to_0'] # 13â„ƒ
    # else: ê¸°ë³¸ê°’ 15â„ƒ ìœ ì§€
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì™¸ê¸°ì˜¨ë„ì— ë”°ë¼ ì—´ë¦¼ ì„ê³„ê°’ì„ ë™ì ìœ¼ë¡œ ì¡°ì •

### ğŸ”§ **ì‹œê°„ ê¸°ë°˜ ë™ì‘ ì œì–´ ë¶€ë¶„**
```python
if sensors['temperature'] >= threshold:
    if not self.start_time:
        self.start_time = current_time
        log_message = f"{logic_name}: ì˜¨ë„ {sensors['temperature']}â„ƒ â‰¥ {threshold}â„ƒ(ì™¸ê¸°ì˜¨{sensors['out_temp']}â„ƒ ë³´ì •)ë¡œ ì—´ë¦¼ ì‹œì‘"
        
    elapsed = (current_time - self.start_time).total_seconds() * 1000
    if elapsed < config.get('action_time', 498000):  # 498ì´ˆ = 8ë¶„ 18ì´ˆ
        return {'status': '498ì´ˆì—´ë¦¼', 'code': 1}
    else:
        if self.last_status != '100%ì—´ë¦¼':
            log_message = f"{logic_name}: 498ì´ˆ ë™ì‘ ì™„ë£Œ, 100% ì—´ë¦¼ ìƒíƒœ"
        self.start_time = None
        return {'status': '100%ì—´ë¦¼', 'code': 1}
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: 498ì´ˆ ë™ì‘ í›„ ì™„ì „ ì—´ë¦¼ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ì‹œê°„ ì œì–´

### ğŸ”§ **êµ¬ê°„ë³„ ëª¨ë“œ ì „í™˜ ë¶€ë¶„**
```python
elif 2 <= section <= 4:
    # ì£¼ê°„ ëª¨ë“œ: í•­ìƒ ì—´ë¦¼
    if self.last_status != '100%ì—´ë¦¼':
        log_message = f"{logic_name}: êµ¬ê°„{section} ì£¼ê°„ ëª¨ë“œë¡œ 100% ì—´ë¦¼"
    return {'status': '100%ì—´ë¦¼', 'code': 1}

elif section == 5:
    # ì €ë… ëª¨ë“œ: ì˜¨ë„ ê¸°ì¤€ ë‹«í˜
    threshold = config.get('threshold', 15)
    # ... (êµ¬ê°„ 1ê³¼ ìœ ì‚¬í•œ ì‹œê°„ ì œì–´ ë¡œì§)

else:
    # ì•¼ê°„ ë³´ì˜¨ ëª¨ë“œ
    if self.last_status != 'ë³´ì˜¨100%':
        log_message = f"{logic_name}: êµ¬ê°„{section} ì•¼ê°„ ë³´ì˜¨ëª¨ë“œ"
    return {'status': 'ë³´ì˜¨100%', 'code': 0}
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ë³„ë¡œ ì™„ì „íˆ ë‹¤ë¥¸ ì œì–´ ì „ëµ ì ìš©

---

## 5. ì°¨ê´‘ìŠ¤í¬ë¦° ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class ShadeController:
    def __init__(self):
        self.start_time = None   # ë™ì‘ ì‹œì‘ ì‹œê°„
        self.stop_time = None    # ëŒ€ê¸° ì‹œì‘ ì‹œê°„
        self.state = 'idle'      # í˜„ì¬ ë™ì‘ ìƒíƒœ
        self.last_status = None  # ì´ì „ ìƒíƒœ
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ë³µì¡í•œ ìƒíƒœ ë¨¸ì‹ ì„ ìœ„í•œ ë‹¤ì¤‘ íƒ€ì´ë¨¸ì™€ ìƒíƒœ ê´€ë¦¬

### ğŸ”§ **ë¹„ ê°ì§€ ìµœìš°ì„  ì²˜ë¦¬ ë¶€ë¶„**
```python
if sensors['rain']:
    logic_name += "_ë¹„ê°ì§€"
    rain_config = shade_config.get('rain_response', {})
    
    # 60ì´ˆ ëŒ€ê¸° í›„ 150ì´ˆ ì—´ë¦¼ ë™ì‘
    if not self.stop_time or (current_time - self.stop_time).total_seconds() * 1000 >= rain_config.get('wait_time', 60000):
        if self.state != 'rain_open':
            self.start_time = current_time
            self.stop_time = None
            self.state = 'rain_open'
            log_message = f"{logic_name}: ê°•ìš° ê°ì§€ë¡œ ë¹„ëŒ€ì‘ ì—´ë¦¼ ì‹œì‘"
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ë¹„ ê°ì§€ ì‹œ ëª¨ë“  ë‹¤ë¥¸ ì¡°ê±´ë³´ë‹¤ ìš°ì„ í•˜ì—¬ ì²˜ë¦¬

### ğŸ”§ **DAT ì¡°ê±´ ê¸°ë°˜ ì‹œê°„ ë‹¨ì¶• ë¶€ë¶„**
```python
section_config = shade_config.get('section_3_4', {})
duration = section_config.get('base_duration', 150000)  # ê¸°ë³¸ 150ì´ˆ

# DAT >= 8 and ì¼ì‚¬ëŸ‰ <= 50 ì‹œ ì§€ì†ì‹œê°„ ì ˆë°˜ìœ¼ë¡œ ë‹¨ì¶•
if dat >= 8 and sensors['light'] <= 50:
    duration *= section_config.get('dat_8_light_50_multiplier', 0.5)
    duration_modifier = f"(DAT{dat}â‰¥8, ì¼ì‚¬ëŸ‰{sensors['light']}â‰¤50ìœ¼ë¡œ ì‹œê°„ë‹¨ì¶•)"
else:
    duration_modifier = ""
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: DAT(ì •ì‹ í›„ ì¼ìˆ˜)ì™€ ì¼ì‚¬ëŸ‰ ì¡°ê±´ìœ¼ë¡œ ë™ì‘ì‹œê°„ ë™ì  ì¡°ì •

### ğŸ”§ **êµ¬ê°„ë³„ ì¼ì‚¬ëŸ‰ ì¡°ê±´ ë¶„ê¸° ë¶€ë¶„**
```python
if section == 3:
    # ì¼ì‚¬ëŸ‰ì´ ë†’ìœ¼ë©´ ì°¨ê´‘
    light_threshold = section_config['section_3']['light_threshold']  # 400
    open_condition = sensors['light'] >= light_threshold
    position = section_config['section_3']['position']  # "30%ì°¨ê´‘"
    condition_text = f"ì¼ì‚¬ëŸ‰ {sensors['light']} â‰¥ {light_threshold}"
else:  # section == 4
    # ì¼ì‚¬ëŸ‰ì´ ë‚®ìœ¼ë©´ ì—´ë¦¼
    light_threshold = section_config['section_4']['light_threshold']  # 400
    open_condition = sensors['light'] <= light_threshold
    position = section_config['section_4']['position']  # "30%ì—´ë¦¼"
    condition_text = f"ì¼ì‚¬ëŸ‰ {sensors['light']} â‰¤ {light_threshold}"
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ 3(ë†’ìœ¼ë©´ ì°¨ê´‘)ê³¼ êµ¬ê°„ 4(ë‚®ìœ¼ë©´ ì—´ë¦¼)ì˜ ë°˜ëŒ€ ì¡°ê±´

### ğŸ”§ **30ë¶„ ëŒ€ê¸° í›„ ì¬ë™ì‘ ê°€ëŠ¥ ë¶€ë¶„**
```python
if (self.state != state_key or not self.start_time or 
    (self.stop_time and (current_time - self.stop_time).total_seconds() * 1000 >= 
     section_config.get('wait_after_action', 1800000))):  # 30ë¶„ = 1800ì´ˆ
    
    if self.state != state_key:
        log_message = f"{logic_name}: {condition_text}ë¡œ {position} ì‹œì‘{duration_modifier}"
    self.start_time = current_time
    self.stop_time = None
    self.state = state_key
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: 30ë¶„ ëŒ€ê¸° í›„ì—ë§Œ ê°™ì€ ë™ì‘ ì¬ì‹¤í–‰ ê°€ëŠ¥

---

## 6. ê´€ìˆ˜ì‹œìŠ¤í…œ ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class IrrigationController:
    def __init__(self):
        self.done = False  # í•˜ë£¨ 1íšŒ ì œí•œ í”Œë˜ê·¸
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ 1ì˜ í•˜ë£¨ 1íšŒ ê´€ìˆ˜ ì œí•œì„ ìœ„í•œ í”Œë˜ê·¸

### ğŸ”§ **êµ¬ê°„ë³„ ê´€ìˆ˜ëŸ‰ ë¡œë“œ ë¶€ë¶„**
```python
amounts = RULES.get('IRRIGATION_AMOUNTS', [])  # [0, 50, 30, 20, 15, 0, 0, 0, 0]
if section >= len(amounts):
    return {'status': 'ëŒ€ê¸°', 'code': 2}, None
    
amount = amounts[section]  # êµ¬ê°„ë³„ ê´€ìˆ˜ëŸ‰ (ml)
soil_threshold = irrigation_config.get('soil_moisture_threshold', 12.5)  # 12.5%
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ë°°ì—´ì—ì„œ êµ¬ê°„ë³„ ê´€ìˆ˜ëŸ‰ ì¶”ì¶œí•˜ê³  ê³µí†µ ì„ê³„ê°’ ì„¤ì •

### ğŸ”§ **êµ¬ê°„ 1 íŠ¹ë³„ ì¡°ê±´ ê²€ì‚¬ ë¶€ë¶„**
```python
if section == 1:
    logic_name += "_íŠ¹ë³„ì¡°ê±´"
    special_config = irrigation_config.get('section_1_special', {})
    dat_threshold = special_config.get('dat_threshold', 7)        # DAT > 7
    sunrise_offset = special_config.get('sunrise_offset_hours', 1)  # ì¼ì¶œ + 1ì‹œê°„
    
    # ì¼ì¶œ + 1ì‹œê°„ ê³„ì‚°
    sunrise_time = datetime.strptime(sensors['sunrise'], '%H:%M').time()
    sunrise_plus_1 = datetime.combine(current_time.date(), sunrise_time) + timedelta(hours=sunrise_offset)
    
    # íŠ¹ë³„ ì¡°ê±´: DAT > 7ì¼ OR ì¼ì¶œ+1ì‹œê°„ ê²½ê³¼
    should_irrigate = dat > dat_threshold or current_time >= sunrise_plus_1
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ 1ë§Œì˜ íŠ¹ë³„ ì¡°ê±´ (DAT ë˜ëŠ” ì‹œê°„) ê²€ì‚¬

### ğŸ”§ **ì¡°ê±´ë³„ ìƒì„¸ ë¡œê¹… ë¶€ë¶„**
```python
if (sensors['soil_moisture'] <= soil_threshold and amount > 0 and 
    should_irrigate and not self.done):
    self.done = True  # í•˜ë£¨ 1íšŒ ì œí•œ
    
    # ì¡°ê±´ ìƒì„¸ ë¡œê¹…
    condition_reason = []
    if dat > dat_threshold:
        condition_reason.append(f"DAT{dat}>7ì¼")
    if current_time >= sunrise_plus_1:
        condition_reason.append(f"ì¼ì¶œ+1ì‹œê°„({sunrise_plus_1.strftime('%H:%M')}) ê²½ê³¼")
        
    log_message = f"{logic_name}: í† ì–‘ìˆ˜ë¶„ {sensors['soil_moisture']}% â‰¤ {soil_threshold}%, {'/'.join(condition_reason)}ë¡œ {amount}ml ê´€ìˆ˜"
    return {'status': f'{amount}mlê´€ìˆ˜', 'code': 1}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ë§Œì¡±í•œ ì¡°ê±´ë“¤ì„ êµ¬ì²´ì ìœ¼ë¡œ ë¡œê·¸ì— ê¸°ë¡

### ğŸ”§ **ì¼ë°˜ êµ¬ê°„ ì²˜ë¦¬ ë¶€ë¶„**
```python
else:
    # êµ¬ê°„ 2-4: ì¼ë°˜ ê´€ìˆ˜ (í† ì–‘ìˆ˜ë¶„ ì¡°ê±´ë§Œ)
    if sensors['soil_moisture'] <= soil_threshold and amount > 0:
        log_message = f"{logic_name}: í† ì–‘ìˆ˜ë¶„ {sensors['soil_moisture']}% â‰¤ {soil_threshold}%ë¡œ {amount}ml ê´€ìˆ˜"
        return {'status': f'{amount}mlê´€ìˆ˜', 'code': 1}, log_message
    else:
        return {'status': 'ëŒ€ê¸°', 'code': 2}, None
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ 2-4ëŠ” í† ì–‘ìˆ˜ë¶„ ì¡°ê±´ë§Œìœ¼ë¡œ ë‹¨ìˆœ ì²˜ë¦¬

---

## 7. ìœ ë™íŒ¬ ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class FanController:
    def __init__(self):
        self.cycle = 0           # í˜„ì¬ ì‚¬ì´í´ íšŸìˆ˜
        self.start_time = None   # ë™ì‘ ì‹œì‘ ì‹œê°„
        self.stop_time = None    # ëŒ€ê¸° ì‹œì‘ ì‹œê°„
        self.last_status = None  # ì´ì „ ìƒíƒœ
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì‚¬ì´í´ ì¹´ìš´í„°ì™€ íƒ€ì´ë¨¸ ê´€ë¦¬

### ğŸ”§ **êµ¬ê°„ 8 ì „ìš© ê²€ì‚¬ ë¶€ë¶„**
```python
if section != fan_config.get('section', 8):  # êµ¬ê°„ 8ì—ì„œë§Œ ë™ì‘
    if self.cycle > 0 or self.start_time or self.stop_time:
        log_message = f"{logic_name}: êµ¬ê°„{section}ì—ì„œ ë¹„í™œì„±, ë¦¬ì…‹"
    self.cycle = 0
    self.start_time = self.stop_time = None
    return {'status': 'ëŒ€ê¸°', 'code': 2}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ 8ì´ ì•„ë‹ˆë©´ ëª¨ë“  ìƒíƒœ ë¦¬ì…‹í•˜ê³  ë¹„í™œì„±

### ğŸ”§ **ì˜¨ë„ì°¨ ê³„ì‚° ë° ì¡°ê±´ ê²€ì‚¬ ë¶€ë¶„**
```python
temp_diff = abs(sensors['temp1'] - sensors['temp2'])
diff_threshold = fan_config.get('temp_diff_threshold', 2)    # 2â„ƒ
max_cycles = fan_config.get('max_cycles', 3)               # ìµœëŒ€ 3ì‚¬ì´í´
run_time = fan_config.get('run_time', 60000)               # 60ì´ˆ ë™ì‘
wait_time = fan_config.get('wait_time', 300000)            # 5ë¶„ ëŒ€ê¸°

if temp_diff >= diff_threshold and self.cycle < max_cycles:
    # ì‚¬ì´í´ ê³„ì† ê°€ëŠ¥
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì˜¨ë„ì°¨ ê³„ì‚°í•˜ê³  ì‚¬ì´í´ í•œê³„ ê²€ì‚¬

### ğŸ”§ **ì‚¬ì´í´ë³„ ë™ì‘ ê´€ë¦¬ ë¶€ë¶„**
```python
if not self.start_time and not self.stop_time:
    # ìƒˆ ì‚¬ì´í´ ì‹œì‘
    self.start_time = current_time
    log_message = f"{logic_name}: ì˜¨ë„ì°¨ {temp_diff:.1f}â„ƒ â‰¥ {diff_threshold}â„ƒë¡œ ì‚¬ì´í´{self.cycle+1} ì‹œì‘"
    return {'status': 'ë™ì‘', 'code': 1}, log_message

elif self.start_time:
    # ë™ì‘ ì¤‘
    elapsed = (current_time - self.start_time).total_seconds() * 1000
    if elapsed < run_time:  # 60ì´ˆ ë™ì‘
        return {'status': 'ë™ì‘', 'code': 1}, None
    else:
        # ë™ì‘ ì™„ë£Œ â†’ 5ë¶„ ëŒ€ê¸°
        self.stop_time = current_time
        self.start_time = None
        log_message = f"{logic_name}: ì‚¬ì´í´{self.cycle+1} 60ì´ˆ ë™ì‘ ì™„ë£Œ, 5ë¶„ ëŒ€ê¸°"
        return {'status': 'ëŒ€ê¸°', 'code': 2}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì‚¬ì´í´ ë‚´ ë™ì‘/ëŒ€ê¸° ìƒíƒœ ì „í™˜ ê´€ë¦¬

### ğŸ”§ **ì¬ì¸¡ì • ë° ì‚¬ì´í´ ì¦ê°€ ë¶€ë¶„**
```python
elif self.stop_time:
    elapsed = (current_time - self.stop_time).total_seconds() * 1000
    if elapsed >= wait_time:  # 5ë¶„ ëŒ€ê¸° ì™„ë£Œ
        self.stop_time = None
        new_temp_diff = abs(sensors['temp1'] - sensors['temp2'])
        
        if new_temp_diff >= diff_threshold:
            self.cycle += 1  # ì‚¬ì´í´ ì¦ê°€
            if self.cycle < max_cycles:
                self.start_time = current_time
                log_message = f"{logic_name}: ëŒ€ê¸°ì™„ë£Œ, ì˜¨ë„ì°¨ {new_temp_diff:.1f}â„ƒë¡œ ì‚¬ì´í´{self.cycle+1} ì‹œì‘"
                return {'status': 'ë™ì‘', 'code': 1}, log_message
            else:
                log_message = f"{logic_name}: ìµœëŒ€ ì‚¬ì´í´{max_cycles} ì™„ë£Œ"
                return {'status': 'ì™„ë£Œ', 'code': 0}, log_message
        else:
            # ì˜¨ë„ì°¨ í•´ì†Œë¨
            self.cycle = 0
            log_message = f"{logic_name}: ì˜¨ë„ì°¨ {new_temp_diff:.1f}â„ƒ < {diff_threshold}â„ƒë¡œ ì •ìƒí™”"
            return {'status': 'ëŒ€ê¸°', 'code': 2}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ëŒ€ê¸° ì™„ë£Œ í›„ ì˜¨ë„ì°¨ ì¬ì¸¡ì •í•˜ì—¬ ì‚¬ì´í´ ì§„í–‰/ì™„ë£Œ/ì •ìƒí™” ê²°ì •

---

## 8. ì²œì°½ ì œì–´

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class WindowController:
    def __init__(self):
        self.phase = 'idle'              # ìƒíƒœ: idle â†’ action â†’ wait â†’ idle
        self.next_action_time = None     # ë‹¤ìŒ ìƒíƒœ ì „í™˜ ì‹œê°„
        self.action_duration = 0         # í˜„ì¬ ë™ì‘ ì§€ì†ì‹œê°„
        self.last_status = None          # ì´ì „ ìƒíƒœ
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: 3ë‹¨ê³„ ìƒíƒœ ë¨¸ì‹ ì„ ìœ„í•œ ìƒíƒœ ë³€ìˆ˜ë“¤

### ğŸ”§ **êµ¬ê°„ë³„ ì¡°ê±´ ì„¤ì • ë¡œë“œ ë¶€ë¶„**
```python
window_config = RULES.get('WINDOW_CONTROL', {})
sections_config = window_config.get('sections', {})
ctrl = sections_config.get(str(section))

if not ctrl:
    self.phase = 'idle'
    return {'status': 'ëŒ€ê¸°', 'code': 2}, None

temp_threshold = ctrl['temp_threshold']
open_time = ctrl.get('open_time_sec', 0)    # ì—´ë¦¼ ì‹œê°„
close_time = ctrl.get('close_time_sec', 0)  # ë‹«í˜ ì‹œê°„
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: êµ¬ê°„ë³„ ì˜¨ë„ ì„ê³„ê°’ê³¼ ë™ì‘ì‹œê°„ ë¡œë“œ

### ğŸ”§ **Phase 1: IDLE (ì¡°ê±´ ê²€ì‚¬) ë¶€ë¶„**
```python
if self.phase == 'idle':
    condition = False
    action_type = ""
    
    # ì—´ë¦¼ ì¡°ê±´ ê²€ì‚¬
    if open_time > 0 and sensors['temperature'] >= temp_threshold:
        condition = True
        self.action_duration = open_time
        action_type = "ì—´ë¦¼"
        condition_text = f"ì˜¨ë„ {sensors['temperature']}â„ƒ â‰¥ {temp_threshold}â„ƒ"
        
    # ë‹«í˜ ì¡°ê±´ ê²€ì‚¬
    elif close_time > 0 and sensors['temperature'] <= temp_threshold:
        condition = True
        self.action_duration = close_time
        action_type = "ë‹«í˜"
        condition_text = f"ì˜¨ë„ {sensors['temperature']}â„ƒ â‰¤ {temp_threshold}â„ƒ"

    if condition:
        # ì¡°ê±´ ë§Œì¡± â†’ ACTION ë‹¨ê³„ë¡œ ì „í™˜
        self.phase = 'action'
        self.next_action_time = current_time + timedelta(seconds=self.action_duration)
        log_message = f"{logic_name}: {condition_text}ë¡œ {action_type} {self.action_duration}ì´ˆ ì‹œì‘"
        return {'status': f'{action_type} ë™ì‘ì¤‘', 'code': 1}, log_message
    else:
        # ì¡°ê±´ ë¶ˆë§Œì¡± â†’ ëŒ€ê¸°
        return {'status': 'ë‹«í˜' if close_time > 0 else 'ëŒ€ê¸°', 'code': 0 if close_time > 0 else 2}, None
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì˜¨ë„ ì¡°ê±´ ê²€ì‚¬í•˜ì—¬ ì—´ë¦¼/ë‹«í˜ ê²°ì •í•˜ê³  ACTION ë‹¨ê³„ ì „í™˜

### ğŸ”§ **Phase 2: ACTION (ë™ì‘ ì¤‘) ë¶€ë¶„**
```python
elif self.phase == 'action':
    if current_time < self.next_action_time:
        # ì•„ì§ ë™ì‘ ì¤‘ (UIìš© ìƒíƒœë§Œ ë°˜í™˜, ë¡œê·¸ ì—†ìŒ)
        action_type = "ì—´ë¦¼" if open_time > 0 else "ë‹«í˜"
        return {'status': f'{action_type} ë™ì‘ì¤‘', 'code': 1}, None
    else:
        # ë™ì‘ ì™„ë£Œ â†’ WAIT ë‹¨ê³„ë¡œ ì „í™˜
        self.phase = 'wait'
        wait_time = window_config.get('wait_time_ms', 300000)  # 5ë¶„
        self.next_action_time = current_time + timedelta(milliseconds=wait_time)
        action_type = "ì—´ë¦¼" if open_time > 0 else "ë‹«í˜"
        log_message = f"{logic_name}: {action_type} {self.action_duration}ì´ˆ ì™„ë£Œ, 5ë¶„ ëŒ€ê¸° í›„ ì¬ì¸¡ì •"
        return {'status': f'{action_type} ì™„ë£Œ', 'code': 2}, log_message
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì„¤ì • ì‹œê°„ë§Œí¼ ë™ì‘ í›„ WAIT ë‹¨ê³„ë¡œ ì „í™˜

### ğŸ”§ **Phase 3: WAIT (ëŒ€ê¸° í›„ ì¬ì¸¡ì •) ë¶€ë¶„**
```python
elif self.phase == 'wait':
    if current_time < self.next_action_time:
        # ì•„ì§ ëŒ€ê¸° ì¤‘ (UIìš© ìƒíƒœë§Œ ë°˜í™˜, ë¡œê·¸ ì—†ìŒ)
        return {'status': 'ì¬ì¸¡ì • ëŒ€ê¸°ì¤‘', 'code': 2}, None
    else:
        # ëŒ€ê¸° ì™„ë£Œ â†’ IDLEë¡œ ëŒì•„ê°€ì„œ ì¬ì¸¡ì •
        self.phase = 'idle'
        log_message = f"{logic_name}: ëŒ€ê¸° ì™„ë£Œ, ì¡°ê±´ ì¬ì¸¡ì •"
        # ì¬ê·€ í˜¸ì¶œë¡œ ì¦‰ì‹œ ì¬ì¸¡ì • ì‹¤í–‰
        return self.update(sensors, section, current_time)
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: 5ë¶„ ëŒ€ê¸° í›„ IDLEë¡œ ëŒì•„ê°€ì„œ ì¡°ê±´ ì¬ê²€ì‚¬

---

## 9. í†µí•© ì œì–´ ì‹œìŠ¤í…œ

### ğŸ”§ **í´ë˜ìŠ¤ ì´ˆê¸°í™” ë¶€ë¶„**
```python
class EnvironmentControlSystem:
    def __init__(self):
        # 8ê°œ ì¥ì¹˜ë³„ ì»¨íŠ¸ë¡¤ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        self.fog_controller = FOGController()
        self.fcu_controller = FCUController()
        self.co2_controller = CO2Controller()
        self.curtain_controller = CurtainController()
        self.shade_controller = ShadeController()
        self.irrigation_controller = IrrigationController()
        self.fan_controller = FanController()
        self.window_controller = WindowController()
        
        self.previous_states = {}      # ìƒíƒœ ë³€ê²½ ê°ì§€ìš©
        self.last_valid_sensors = None # ì„¼ì„œ ì˜¤ë¥˜ ë³µêµ¬ìš©
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: 8ê°œ ë…ë¦½ ì»¨íŠ¸ë¡¤ëŸ¬ì™€ ê³µí†µ ìƒíƒœ ê´€ë¦¬ ë³€ìˆ˜ ì´ˆê¸°í™”

### ğŸ”§ **ì„¼ì„œ ê²€ì¦ ë° ì˜¤ë¥˜ ë³µêµ¬ ë¶€ë¶„**
```python
def validate_sensors(self, sensors, current_time):
    valid_sensors = sensors.copy()
    has_invalid = False
    
    for key, value in sensors.items():
        if key not in ['sunrise', 'sunset', 'temp1', 'temp2']:
            if not validate_sensor(value, key):  # SENSOR_LIMITS ê²€ì‚¬
                has_invalid = True
                if self.last_valid_sensors and key in self.last_valid_sensors:
                    valid_sensors[key] = self.last_valid_sensors[key]
                    # ì„¼ì„œ ì˜¤ë¥˜ ë¡œê·¸ë„ ì—¬ê¸°ì„œ ìƒì„± ê°€ëŠ¥
                    
    if not has_invalid or not self.last_valid_sensors:
        self.last_valid_sensors = valid_sensors.copy()
        
    return valid_sensors
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ë²”ìœ„ ë²—ì–´ë‚œ ì„¼ì„œê°’ì„ ì´ì „ ìœ íš¨ê°’ìœ¼ë¡œ ìë™ ëŒ€ì²´

### ğŸ”§ **ì „ì²´ ì œì–´ ë¡œì§ ìˆœì°¨ ì‹¤í–‰ ë¶€ë¶„**
```python
def apply_control_logic(self, sensors, section, current_time, dat):
    # ì„¼ì„œ ê²€ì¦
    valid_sensors = self.validate_sensors(sensors, current_time)
    
    results = {}
    log_messages = []
    
    # ê° ì¥ì¹˜ë³„ ì œì–´ ë¡œì§ ìˆœì°¨ ì‹¤í–‰
    fog_result, fog_log = self.fog_controller.update(valid_sensors, section, current_time)
    results['fog'] = fog_result
    if fog_log: log_messages.append(('fog', fog_log))
    
    fcu_result, fcu_log = self.fcu_controller.update(valid_sensors, section, current_time)
    results['fcu'] = fcu_result
    if fcu_log: log_messages.append(('fcu', fcu_log))
    
    # ... (8ê°œ ì¥ì¹˜ ëª¨ë‘)
    
    return results, log_messages
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ê²€ì¦ëœ ì„¼ì„œê°’ìœ¼ë¡œ 8ê°œ ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ìˆœì°¨ ì‹¤í–‰í•˜ê³  ë¡œê·¸ ìˆ˜ì§‘

### ğŸ”§ **ì¼ì¼ ìƒíƒœ ë¦¬ì…‹ ë¶€ë¶„**
```python
def reset_daily_states(self):
    """ìì •ë§ˆë‹¤ í˜¸ì¶œë˜ì–´ ì¼ì¼ ì œí•œ ìƒíƒœë“¤ì„ ë¦¬ì…‹"""
    self.irrigation_controller.reset_daily()  # ê´€ìˆ˜ ì™„ë£Œ í”Œë˜ê·¸ ë¦¬ì…‹
    # í•„ìš”ì‹œ ë‹¤ë¥¸ ì»¨íŠ¸ë¡¤ëŸ¬ì˜ ì¼ì¼ ìƒíƒœë„ ì¶”ê°€
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ë‚ ì§œ ë³€ê²½ ì‹œ ì¼ì¼ ì œí•œ ìƒíƒœë“¤ì„ ìë™ ë¦¬ì…‹

### ğŸ”§ **ë¡œê·¸ ìƒì„± ë° UI ì—°ë™ ë¶€ë¶„**
```python
# streamlit_app.pyì˜ update_simulation() í•¨ìˆ˜ì—ì„œ
control_results, log_messages = st.session_state.control_system.apply_control_logic(
    sensors, section, st.session_state.current_time, current_dat
)

# ìƒì„¸ ë¡œê·¸ ë©”ì‹œì§€ë“¤ ê¸°ë¡
for device, message in log_messages:
    add_log(device, message)  # ê°€ìƒì‹œê°„ í¬í•¨ ë¡œê·¸ ìƒì„±
```
ğŸ‘† **ì´ ë¶€ë¶„ì€**: ì œì–´ ë¡œì§ì—ì„œ ë°˜í™˜ëœ ë¡œê·¸ë“¤ì„ ê°€ìƒì‹œê°„ í¬í•¨ í˜•íƒœë¡œ UIì— í‘œì‹œ

---

## ğŸ“Š ì „ì²´ ì•„í‚¤í…ì²˜ ìš”ì•½

### **ğŸ”„ ì‹¤í–‰ íë¦„**
```
1. streamlit_app.py 
   â†“ (200msë§ˆë‹¤)
2. update_simulation()
   â†“
3. EnvironmentControlSystem.apply_control_logic()
   â†“
4. ì„¼ì„œ ê²€ì¦ â†’ 8ê°œ ì»¨íŠ¸ë¡¤ëŸ¬ ìˆœì°¨ ì‹¤í–‰ â†’ ë¡œê·¸ ìˆ˜ì§‘
   â†“
5. UI ìƒíƒœ ì—…ë°ì´íŠ¸ + ë¡œê·¸ í‘œì‹œ
```

### **ğŸ“ ë¡œê·¸ ìƒì„± ê·œì¹™**
- **ìƒíƒœ ë³€ê²½ ì‹œì—ë§Œ** ë¡œê·¸ ìƒì„±
- **êµ¬ì²´ì ì¸ ì„¼ì„œê°’ê³¼ ì„ê³„ê°’** í¬í•¨  
- **ë³´ì • ì¡°ê±´ê³¼ íŠ¹ë³„ ì¡°ê±´** ìƒì„¸ ê¸°ë¡
- **ê°€ìƒì‹œê°„ + DAT + ë°°ì†** ì •ë³´ ì¶”ê°€

### **âš™ï¸ ì„¤ì • ê´€ë¦¬**
- **business_rules.json**: ëª¨ë“  ì„ê³„ê°’ê³¼ ì‹œê°„ ì„¤ì •
- **ëŸ°íƒ€ì„ ë³€ê²½ ì—†ì´** JSON ìˆ˜ì •ìœ¼ë¡œ ë£° ì¡°ì • ê°€ëŠ¥
- **êµ¬ê°„ë³„/ì¥ì¹˜ë³„** ë…ë¦½ì ì¸ ì„¤ì • êµ¬ì¡°

---

**ì‘ì„± ì™„ë£Œì¼:** 2025-08-29  
**ì´ ì½”ë“œ ë¼ì¸:** ì•½ 1,500ì¤„  
**êµ¬í˜„ ì–¸ì–´:** Python 3.8+  
**UI í”„ë ˆì„ì›Œí¬:** Streamlit